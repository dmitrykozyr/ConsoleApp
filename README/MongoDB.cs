// Показать все БД, 2 команды
show databases
show dbs

// Выбрать БД
use [database name]

// Показать все коллекции текущей БД
show collections
 
db.users.insertOne({"name": "Tom", "age": 28, "languages": ["english", "spanish"]})
 
db.users.insertOne({ "_id": 123457, "name": "Tom", "age": 28, "languages": ["english", "spanish"]})
 
db.users.insertOne({ "_id": ObjectId("62e27b1b06adfcddf4619fc6"), "name": "Tom", "age": 28, "languages": ["english", "spanish"]})
 
b.users.insertMany([
{ "name": "Bob", "age": 26, "languages": ["english", "french"]}, 
{ "name": "Joe", "age": 31, "languages": ["german", "english"]}
])
 
document = ({ "name": "Bill", "age": 32, "languages": ["english", "french"]})
db.users.insertOne(document)

// Вывести все документы коллекции
db.users.find()

// Вывести документы, в которых 'name=Tom'
db.users.find({ name: "Tom"})
 
// Вывести документы, в которых 'name=Tom' и 'age=32'
db.users.find({ name: "Tom", age: 32})
 
// Вывести документы, в которых свойство 'languages' пустое
db.users.find({ languages: null})
 
// Вывести документы, в которых в массиве 'languages' есть 'english'
db.users.find({ languages: "english"})
 
// Вывести документы, в которых в массиве 'languages' есть 'english' и 'german'
db.users.find({ languages: ["english", "german"]})
 
// Вывести документы, в которых 'english' в массиве 'languages' находится на ПЕРВОМ месте
// 'languages.0' предоставляет сложное свойство и поэтому берется в кавычки
db.users.find({ "languages.0": "english"})
 
// Вывести документы, в которых 'english' в массиве 'languages' находится на ВТОРОМ месте
// 'languages.0' предоставляет сложное свойство и поэтому берется в кавычки
db.users.find({ "languages.1": "english"})
 
// Документ может иметь множество полей, но не все эти поля нам могут быть нужны
// Выведем значения полей 'age' у всех документов, в которых 'name=Tom'
// 'age: 1' указывает, что нужно вернуть только свойство 'age'
db.users.find({ name: "Tom"}, { age: 1})
 
// Вывести поля документа, кроме свойства 'age'
// Вместо 1 и 0 можно использовать 'true' и 'false'
db.persons.find({ name: "Tom"}, { age: 0})
 
// Запрос к вложенным объектам
db.users.insertOne({ "name": "Alex", "age": 28, company: { "name":"Microsoft", "country":"USA"} })
db.users.find({ "company.name": "Microsoft"})
 
// Курсор - это результат выборки, получаемой функцией 'find'
var cursor = db.users.find()
 
// Ограничение числа получаемых документов
db.users.find().limit(3)
 
// Пропустим первые три записи и выведем последующие
db.users.find().skip(3)
 
// Вывести документы с 4 по 6
db.users.find().skip(3).limit(3)
 
// Сортировка по полю
// 1 - по возрастанию
// -1 - по убыванию

Amazing User, [08.04.2024 12:25]
db.users.find().sort({ name: 1})
 
// Оператор $slice
// Это комбинация операторов 'limit' и 'skip', которая может работтаь с массивом
// Запрос вернет только первый язык из массива 'languages', в данном случае 'english'
db.users.insertOne({ "name": "Tom", "age": 32, languages: ["english", "german", "spanish"]})
db.users.find({ name: "Tom"}, { languages: {$slice: 1} })
 
// Обратная ситуация - оставить в массиве один элемент, но не с начала, а с конца
// В данном случае 'spanish'
db.users.find({ name: "Tom"}, { languages: {$slice: -1} });

// Первый параметр говорит начать выборку элементов с конца (так как отрицательное значение)
// Второй параметр указывает на количество возвращаемых элементов массива
// В итоге в массиве language окажется 'german'
db.users.find({ name: "Tom"}, { languages: {$slice: [-2, 1]} });

// Создать индекс для поля 'name'
db.users.createIndex({ "name" : 1})
 
// Создать несколько индексов
db.users.createIndexes([{ "name" : 1}, { "age": 1}])
 
// Удаление индексов
db.users.dropIndex("name_1")

// Запретить добавлять документ с неуникальным ключом
// Есть нюанс - документ может не иметь ключа 'name'
// Тогда для добавляемого документа автоматически создается ключ 'name' со значением 'null'
// Поэтому, при добавлении второго документа, в котором не определен ключ 'name',
// будет выброшено исключение, так как ключ 'name' со значением 'null' уже существует
db.users.createIndex({ "name" : 1}, { "unique" : true})
 
// Можно задать один индекс сразу для двух полей
// Тогдп все добавляемые документы должны иметь уникальные значения для обоих полей
db.users.createIndex({ "name" : 1, "age" : 1})
 
// Вывести всю информацию об индексах для конкретной коллекции
db.users.getIndexes()

// Число элементов в коллекции
db.users.find({ name: "Tom"}).count()

// Можем создавать цепочки функций, чтобы конкретизировать условия подсчета
db.users.find({ name: "Tom"}).skip(2).count(true)

// Вывести все уникальные значения по полю 'name'
db.users.distinct("name")

// Функции min и max могут использовать только те поля, для которых установлены индексы
db.users.createIndex({ "age": 1})
db.users.find().min({ age: 30}).hint({ age: 1})
db.users.find().max({ age: 30}).hint({ age: 1})
 
// Условные операторы
// Сравнение проводится над целочисленными типами, а не строками
// $eq  ==
// $ne  !=
// $gt  >
// $lt  <
// $gte >=
// $lte <=
// $in  определяет массив значений, одно из которых должно иметь поле документа
// $nin определяет массив значений, которые не должно иметь поле документа
db.users.find({ age: {$lt: 30} })
db.users.find({ age: {$gt: 30} })
db.users.find({ age: {$gt: 30, $lt: 50} })
db.users.find({ age: {$eq: 22} }) // Ниже аналогичный запрос
db.users.find({ age: 22})
db.users.find({ age: {$ne: 22} })
db.users.find({ age: {$in : [22, 32]} })
db.users.find({ age: {$nin: [22, 32]} })
 
// Логические операторы
// $or документ должен соответствовать одному из двух условий
// $and документ должен соответствовать обоим условиям
// $not документ должен НЕ соответствовать условию
// $nor документ должен НЕ соответстовать обоим условиям
db.users.find({$or: [{ name: "Tom"}, { age: 22}]})
db.users.find({ name: "Tom", $or: [{ age: 22}, { languages: "german"}]})
db.users.find({$or: [{ name: "Tom"}, { age: {$gte: 30} }]})
db.users.find({$and: [{ name: "Tom"}, { age: 22}]})
 
// Поиск по массивам
// $all   определяет набор значений, которые должны иметься в массиве
// $size  определяет количество элементов, которые должны быть в массиве
// $elemMatch определяет условие, которым должны соответствовать элемены в массиве
db.users.find({ languages: {$all: ["english", "french"]} })
 
db.grades.insertMany([
{ student: "Tom",   courses: [{ name: "Java", grade: 5}, { name: "MongoDB", grade: 4}]},

Amazing User, [08.04.2024 12:25]
db.users.find().sort({ name: 1})
 
// Оператор $slice
// Это комбинация операторов 'limit' и 'skip', которая может работтаь с массивом
// Запрос вернет только первый язык из массива 'languages', в данном случае 'english'
db.users.insertOne({ "name": "Tom", "age": 32, languages: ["english", "german", "spanish"]})
db.users.find({ name: "Tom"}, { languages: {$slice: 1} })
 
// Обратная ситуация - оставить в массиве один элемент, но не с начала, а с конца
// В данном случае 'spanish'
db.users.find({ name: "Tom"}, { languages: {$slice: -1} });

// Первый параметр говорит начать выборку элементов с конца (так как отрицательное значение)
// Второй параметр указывает на количество возвращаемых элементов массива
// В итоге в массиве language окажется 'german'
db.users.find({ name: "Tom"}, { languages: {$slice: [-2, 1]} });

// Создать индекс для поля 'name'
db.users.createIndex({ "name" : 1})
 
// Создать несколько индексов
db.users.createIndexes([{ "name" : 1}, { "age": 1}])
 
// Удаление индексов
db.users.dropIndex("name_1")

// Запретить добавлять документ с неуникальным ключом
// Есть нюанс - документ может не иметь ключа 'name'
// Тогда для добавляемого документа автоматически создается ключ 'name' со значением 'null'
// Поэтому, при добавлении второго документа, в котором не определен ключ 'name',
// будет выброшено исключение, так как ключ 'name' со значением 'null' уже существует
db.users.createIndex({ "name" : 1}, { "unique" : true})
 
// Можно задать один индекс сразу для двух полей
// Тогдп все добавляемые документы должны иметь уникальные значения для обоих полей
db.users.createIndex({ "name" : 1, "age" : 1})
 
// Вывести всю информацию об индексах для конкретной коллекции
db.users.getIndexes()

// Число элементов в коллекции
db.users.find({ name: "Tom"}).count()

// Можем создавать цепочки функций, чтобы конкретизировать условия подсчета
db.users.find({ name: "Tom"}).skip(2).count(true)

// Вывести все уникальные значения по полю 'name'
db.users.distinct("name")

// Функции min и max могут использовать только те поля, для которых установлены индексы
db.users.createIndex({ "age": 1})
db.users.find().min({ age: 30}).hint({ age: 1})
db.users.find().max({ age: 30}).hint({ age: 1})
 
// Условные операторы
// Сравнение проводится над целочисленными типами, а не строками
// $eq  ==
// $ne  !=
// $gt  >
// $lt  <
// $gte >=
// $lte <=
// $in  определяет массив значений, одно из которых должно иметь поле документа
// $nin определяет массив значений, которые не должно иметь поле документа
db.users.find({ age: {$lt: 30} })
db.users.find({ age: {$gt: 30} })
db.users.find({ age: {$gt: 30, $lt: 50} })
db.users.find({ age: {$eq: 22} }) // Ниже аналогичный запрос
db.users.find({ age: 22})
db.users.find({ age: {$ne: 22} })
db.users.find({ age: {$in : [22, 32]} })
db.users.find({ age: {$nin: [22, 32]} })
 
// Логические операторы
// $or документ должен соответствовать одному из двух условий
// $and документ должен соответствовать обоим условиям
// $not документ должен НЕ соответствовать условию
// $nor документ должен НЕ соответстовать обоим условиям
db.users.find({$or: [{ name: "Tom"}, { age: 22}]})
db.users.find({ name: "Tom", $or: [{ age: 22}, { languages: "german"}]})
db.users.find({$or: [{ name: "Tom"}, { age: {$gte: 30} }]})
db.users.find({$and: [{ name: "Tom"}, { age: 22}]})
 
// Поиск по массивам
// $all   определяет набор значений, которые должны иметься в массиве
// $size  определяет количество элементов, которые должны быть в массиве
// $elemMatch определяет условие, которым должны соответствовать элемены в массиве
db.users.find({ languages: {$all: ["english", "french"]} })
 
db.grades.insertMany([
{ student: "Tom",   courses: [{ name: "Java", grade: 5}, { name: "MongoDB", grade: 4}]},

Amazing User, [08.04.2024 12:25]
{ student: "Alice", courses: [{ name: "C++",  grade: 3}, { name: "MongoDB", grade: 5}]}])
 
db.grades.find({ courses: {$elemMatch: { name: "MongoDB", grade: {$gt: 4} } } })
 
// $size - ищем документы, в которых массивы имеют заданное число элементов
db.users.find({ languages: {$size: 2} })
 
// $exists - ищет документы, в которых указанный ключ присутствует или отсутствует
db.users.find({ company: {$exists: true} })
 
// $type - ищет документы, в которых указанный ключ имеет указанный тип
db.users.find({ age: {$type: "string"} })

Amazing User, [08.04.2024 12:25]
db.users.find({ age: {$type: "number"} })
 
// $regex - задает регулярное выражение, которому должно соответствовать значение поля
// Пусть поле name обязательно имеет букву 'b'
 
db.users.find({ name: {$regex: "b"} })
 
// $regex принимает не просто строки, а регулярные выражения
// Например значение 'name' должно оканчиваться на 'om'
db.users.find(name: {$regex: "om$"})
 
//########################## Обновление данных ##########################
 
// replaceOne - заменить один документ другим
// - filter принимает запрос на выборку документа, который надо обновить
// - update представляет новый документ, который заместит старый
// - options определяет дополнительные параметры, основным из которых является параметр upsert
//  если 'upsert' == 'true' - документ обновится, если он найден, иначебудет создан новый
//   если 'upsert' == 'false' - новый документ не будет создан, если не будет найден
db.collection.replaceOne(filter, update, options)

// Находим документ с 'name=Bob' и заменяем его на' {name: "Bob", age: 25}'
db.users.replaceOne({ name: "Bob"}, { name: "Bob", age: 25})
 
// Чтобы не обновлять весь документ, а одно или несколько его свойств, используем:
// - updateOne() - обновляем только один документ
// - updateMany() - обновляем множество документов
// Для обновления отдельных полей в этих функциях применяется оператор $set
// Если документ не содержит обновляемое поле - оно создается
db.users.updateOne({ name: "Tom", age: 22}, {$set: { age: 28} })
db.users.updateMany({ name: "Tom"}, {$set: { name: "Tomas"} })
db.users.updateOne({ name: "Tom", age: 28}, {$set: { salary: 300} })
db.users.updateOne({ name: "Tom"}, {$set: { name: "Tomas", age: 25} })
 
// $inc увеличивает значение числового поля на определенное количество единиц
db.users.updateOne({ name: "Tom"}, {$inc: { age: 2} })
 
// $unset - удаляет отдельный ключ
db.users.updateOne({ name: "Tom"}, {$unset: { salary: 1} })
 
// Удаление нескольких полей
db.users.updateOne({ name: "Tom"}, {$unset: { salary: 1, age: 1} })
 
 //########################## Обновление массивов ##########################
 
 // $push позволяет добавить еще одно значение к существующему
 // Например, если ключ в качестве значения хранит массив
 // Если ключ, для которого хотим добавить значение, не представляет массив - получим ошибку
 db.users.updateOne({ name: "Tom"}, {$push: { languages: "russian"} })
 db.users.updateMany({ name: "Tom"}, {$push: { languages: "russian"} })

 // $each позволяет добавить сразу несколько значений
 db.users.updateOne({ name: "Tom"}, {$push: { languages: {$each: ["russian", "spanish", "italian"]} } })

 // $position задает позицию в массиве для вставки элементов
 // $slice указывает, сколько элементов оставить в массиве после вставки
 // В данном случае элементы ["german", "spanish", "italian"] будут вставляться в массив 'languages'
 // с 1-го индекса, а после вставки в массиве останутся только 5 первых элементов
 db.users.updateOne({ name: "Tom"}, {$push: { languages: {$each: ["german", "spanish", "italian"], $position: 1, $slice: 5} } })

 // $addToSet подобно оператору $push добавляет объекты в массив
 // Но $addToSet добавляет данные, если их еще нет в массиве,
 // а при добавлении через $push данные дублируются, если добавляются элементы, которые уже есть
 db.users.updateOne({ name: "Tom"}, {$addToSet: { languages: "russian"} })

 // $pop удаляет элемент из массива
 db.users.updateOne({ name: "Tom"}, {$pop: { languages: 1} })

 // Указывая для ключа 'languages' значение 1, мы удаляем первый элемент с конца массива
 // Чтобы удалить первый элемент с начала - надо передать отрицательное значение
 db.users.updateOne({ name: "Tom"}, {$pop: { languages: -1} })

 // $pull удаляет каждое вхождение элемента в массив
 // Например, через оператор $push можем добавить значение в массив несколько раз
 // И теперь с помощью $pull удалим его
 db.users.updateOne({ name: "Tom"}, {$pull: { languages: "english"} })

 // $pullAll удаляет не одно значение, а сразу несколько
 db.users.updateOne({ name: "Tom"}, {$pullAll: { languages: ["english", "german", "french"]} })

 // Удаление первого найденного документа с 'name=Tom'
 db.users.deleteOne({ name: "Tom"})

 // Удаление всех документов по заданному фильтру
 db.users.deleteMany({ name: "Tom"})

 // Можем задать условия выборки для удаления в виде регулярных выражений и условных конструкций
 db.users.deleteOne({ name: / ^T\w +/ i})
 db.users.deleteOne({ age: {$lt: 30} })

 // Удалить все документы из коллекции
 db.users.deleteMany({ })

 // Удаление коллекций БД
 db.users.drop()

 // Удаление всей БД
 db.dropDatabase()

 //######################### Установка ссылок в БД #########################

// В реляционных БД можно устанавливать внешние ключи, когда поля одной таблицы ссылаются на поля другой
// В MongoDB можно устанавливать ссылки
// Рассмотрим установку ссылок между коллекциями 'users' и 'companies'

// РУЧНАЯ УСТАНОВКА ССЫЛОК
// Сводится к присвоению значения поля '_id' одного документа полю другого документа
// Допустим, могут быть коллекции, представляющие компании и работников, работающих в этих компаниях
// Добавим в коллекцию 'companies' документ, представляющий компанию
 db.companies.insertOne({ "_id" : "microsoft", year: 1974})
 
 // Добавим в коллекцию 'users' документ, представляющий работника
 // В нем будет поле 'company', представляющее компанию, где работает работник
 // Очень важно, что в качестве значения для этого поля мы устанавливаем не объект 'company',
 // а значение ключа '_id'
 db.users.insertOne({ name: "Tom", age: 28, company: "microsoft"})
 
 // Получим документ из коллекции users:

user = db.users.findOne()

 // Выше добавленный элемент будет единственным в коллекции,
 // иначе надо сделать выборку по '_id' последнего добавленого документа
 // Найдем ссылку на его компанию в коллекции 'ompanies'
 db.companies.findOne({ _id: user.company})
 
 // АВТОМАТИЧЕСКОЕ СВЯЗЫВАНИЕ
 // Используя функциональность DBRef можем установить автоматическое связывание между документами
 // Добавим новый документ в коллекцию 'companies'
 google = db.companies.insertOne({ name: "google", year: 1998})
 
 // Получаем результат добавления в переменную 'google'
 // При добавлении нового документа генерирует '_id',
 // который можем получить с помощью свойства 'insertedId' результата функции
 // Создадим новый документ для коллекции 'users',
 // у которого ключ 'company' свяжем с только что добавленным документом 'google'
 sam = ({ name: "Sam", age: 25, company: { "$ref" : "companies", "$id" : google.insertedId} })
 db.users.insertOne(sam)

 // Можем протестировать
 db.companies.findOne({ _id: sam.company.$id})
 
 // Разберем организацию ссылок между документами
 // Для связывания с документом 'google' использовалось выражение
 { "$ref" : "companies", "$id" : google.insertedId}

// Формальный синтаксис DBRef следующий
{ "$ref" : название_коллекции, "$id": значение[, "$db" : название_бд]}

// Первый параметр $ref указывает на коллекцию, где хранится связанный документ
// Второй параметр указывает на значение, которое будет представлять внешний ключ
// Третий необязательный параметр указывает на БД
// При тестировании в качестве запроса на выборку указывается выражение 
_id: sam.company.$id

 // Так как 'sam.company' представляет теперь объект 
 { "$ref" : "companies", "$id" : google.insertedId}
 
 // то надо конкретизировать параметр 'sam.company.$id'
 
 //######################### Управление коллекцией #########################
 
 // ЯВНОЕ СОЗДАНИЕ КОЛЛЕКЦИИ
 // Ранее коллекция создавалась автоматически при добавлении в нее первых данных
 // Можем создать ее явно, применив метод db.createCollection(name, options), где
 // - name - название коллекции
 // - options - необязательный объект с дополнительными настройками инициализации
 db.createCollection("accounts")

 // Переименование коллекции
 db.users.renameCollection("новое_название")

 // ОГРАНИЧЕННЫЕ КОЛЛЕКЦИИ
 // При отправке запроса в БД, MongoDB возвращает документы в порядке, в котором они были добавлены
 // Такой порядок не всегда гарантирован, так как данные могут быть удалены, перемещены, изменены
 // Поэтому в MongoDB существуют ограниченные коллекции
 // Они гарантируют расположение документов в том порядке, в котором они добавлялись в коллекцию
 // Ограниченные коллекции имеют фиксированный размер и если в коллекции нет места,
 // наиболее старые документы удаляются, а в конец добавятся новые
 // Создадим ограниченную коллекцию с названием 'profiles' и зададим для нее размер 9500 байт
 db.createCollection("profiles", { capped: true, size: 9500})
 
 // Можно ограничить количество документов в коллекции, указав его в параметре 'max'
 db.createCollection("profiles", { capped: true, size: 9500, max: 150})
 
 // Если выделенные нами 9500 байтов заполнены, а количество документов еще не достигло максимума,
 // в данном случае 150, то при добавлении нового документа самый старый будет удален,
 // а на его место вставлен новый

 // При обновлении документов в таких коллекциях надо помнить,
 // что документы не должны расти в размерах, иначе обновление не удастся

 // Нельзя удалять документы из подобных коллекций, можно только удалить всю коллекцию
 
 // ПОДКОЛЛЕКЦИИ
 // Для упрощения организации данных в коллекциях можем использовать подколлекции
 // Например, данные коллекции 'users' надо разграничить на профили и учетные данные
 // Можем создать коллекции:
 // - db.users.profiles
 // - db.users.accounts
 // Они не будут связаны с коллекцией 'users'
 // Это будут три разные коллекции, но в плане логической организации будут проще для понимания

