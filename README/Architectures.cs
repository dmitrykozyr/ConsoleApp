using static System.Net.WebRequestMethods;

public class A
{
	#region Физическая архитектура (Monolith, N-Tier, Service-Oriented, Microservices, Peer to peer)
			
		// Monolith
		Для небольших приложений
		+ Простая структура
		+ Просто тестировать
		+ Просто деплоить
		+ Запросы быстро передаются между частями программы
		- Код быстро усложняется
		- Сложно поддерживать и расширять

		// N-Tier
		Приложение разделяется на несколько tiers (устаревшая архитектура):
		- Presentation	(Браузер)
		- BuisnessLogic	(Веб-сервер на каком-либо хостинге)
		- Data			(БД)

		Браузер и БД общаются через веб-сервер
		Если ничего не сохраняется в БД, слой Data не нужен
		Элементов Presentation обычно мого, т.к. к одному веб-серверу могут обращаться из многих браузеров

		+ Tiers могут быть физически разделены, то есть быть на разных машинах
		+ Могут разрабатываться независимо друг от друга
		+ В случае большой нагрузки можно добавить веб-сервер(ы) и балансировщик нагрузки
		- Изменения в одном Tier могут требовать изменений в другом

		// Service-Oriented architecture (SOA)
        SOA использует сервисы как основные строительные блоки для создания приложений
		Сервисы взаимодействуют через интерфейсы, основанные на протоколах SOAP или REST
		Использует централизованный компонент Enterprise Service Bus (ESB) для управления взаимодействием между сервисами
        Сервисы могут быть крупными и сложными, объединяя несколько функций в одном сервисе, что может привести к более сложной интеграции и управлению
        Может требовать централизованного подхода к разработке и развертыванию, так как сервисы могут быть взаимозависимыми и требовать согласования изменений
        Обычно работает с состоянием, которое может храниться в централизованных системах, таких как БД или кэш
        Обычно использует стандартизированные технологии и протоколы, что может ограничивать выбор технологий.
        Для SOA можно использовать WCF для создания сервисов с поддержкой SOAP и других протоколов
        Ошибки в ESB могут сломать всю систему

        // Microservices
        Состоит из нескольких сервисов, каждый отвечает за свою бизнес-активность		
		Слабая связность, простая расширяемость
		Позволяет автоматизировать тестирование, деплоймент и мониторинг
		Обычно используют RESTful API
        Сервисы общаются напрямую через HTTP/REST или gRPC
        Позволяют командам работать независимо над разными сервисами
		Каждая команда может использовать разные технологии и языки программирования
        stateless - каждый вызов сервиса не зависит от предыдущих вызовов
        Для микросервисов можно использовать ASP.NET Core для создания RESTful API, а также Docker и Kubernetes для контейнеризации и управления развертыванием

        // Peer to peer
        Нет центрального сервера, машины общаются напрямую

    #endregion

    #region Логическая архитектура (Layered, MVC, MVVM)

        // Layered
        Есть несколько слоев, по которым идет запрос от первого к последнему, но не наоборот

		- Presentation:				UI
		- Application (Service):    Translate between UI and business logic
		- Business logic					
		- Persistence:				Code to interact with DB
		- Data

		+ Легко написать, код структурирован
		+ Благодаря изолированности слоев, изменение логики в одном слое не требует изменения в другом
		- Такой подход ведет к монолитному приложению, который потом сложно разбить на сервисы
		- Нужно писать много кода, чтобы перебрасывать запрос с одного слоя на другой

		// MVC
		Для подключения к БД нужно:
		- в appsettings.json указать ConnectionString
		- создать модель
		- в папке Data создать класс ApplicationDbContext, добавить туда тип модели
		- установить пакет Microsoft.EntityFrameworkCore.SqlServer
		- в Program.cs добавить AddDbContext
		- для создания миграций установить пакет Microsoft.EntityFrameworkCore.Tools
		- в Package Console Manager создать миграцию:
		- add-migration [Migration name]
		- update-database
		- в БД увидим новую таблицу

		Папка wwwroot нужнa для статичных файлов (картинок, js кода, css)
		Если есть HomeController, то в папке Views должна быть папка Home и в ней лежать нужные Views,
		а их имя должно совпадать с action-методами в HomeController
		В папке Views есть папка Shared, в ней находятся View, которые могут быть вызваны из других View

		// MVVM
		Когда создали Model, View и ViewModel, нужно создать команды в папке Commands,
		которые обрабатывают события нажатия на кнопки
		CommandBase - абстрактный класс с базовым функционалом всех комманд

	#endregion
}